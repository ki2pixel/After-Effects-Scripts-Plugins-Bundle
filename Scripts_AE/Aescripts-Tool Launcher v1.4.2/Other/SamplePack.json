{	"name": "ToolPack",	"author": "Rune GangsÃ¸",
	"version": "v1.0",
	"tools": [		{			"name": "Stretch Layers",			"shortname": "SL",			"description": "Stretches selected layers to fit comp duration ( including preComps )",			"icon": "",			"cmd": {				"type": "javascript",				"cmd": "( function() {\n// Create an undogroup named \"Stretch\" so the action the script runs can be undone\naeq.undoGroup( \"Stretch\", function() {\n\n\t// Get the selected layers from the currently active comp\n\tvar layers = aeq.getSelectedLayers();\n\n\t// Do a function for each of the selected layers\n\taeq.forEach( layers, function( layer ) {\n\n\t\t// If the layer is a precomp the duration of the precomp should be adjusted\n\t\tif ( aeq.isComp( layer.source ) ) {\n\t\t\tstretchPrecomp( layer );\n\t\t}\n\n\t\t// Make the outpoint of the layer the same as the duration of the comp\n\t\tstretchLayer( layer );\n\t} );\n} );\n\nfunction stretchPrecomp( compLayer ) {\n\tvar oldDuration, containingComp, newDuration;\n\n\t// Store the duration of the precomp, so the value can be used later to\n\t// determine if a layer should be adjusted\n\toldDuration = compLayer.source.duration;\n\tcontainingComp = compLayer.containingComp;\n\n\t// Calculate the new duration based on the duration of the comp the precomp\n\t// is in, the inPoint and stretch of the precomp layer\n\tnewDuration = (containingComp.duration - compLayer.inPoint) / Math.abs(compLayer.stretch / 100 );\n\n\t// The duration should be rounded up to the nearest frame. AE always rounds to\n\t// the nearest frame, both up and down, but we always want to round up.\n\tnewDuration = ceilFrame( newDuration, compLayer.source );\n\n\t// Set the new duration\n\tcompLayer.source.duration = newDuration;\n\n\t// Loop through the precomp layers and stretch only the layers and precomps\n\t// that go to the end of this precomp.\n\taeq.forEachLayer( compLayer.source, function( layer ) {\n\n\t\t// To determine that the function need to know the previous duration of the\n\t\t// precomp, so we pass that in as an argument.\n\t\tmaybeStretch( layer, oldDuration );\n\t} );\n}\n\nfunction stretchLayer( layer ) {\n\tvar locked, oldOutPoint;\n\n\t// We cannot stretch the layer if the layer is locked, so we store the value\n\t// of the \"locked\" attribute, so we can set it to what it was before.\n\tlocked = layer.locked;\n\n\t// Unlock the layer\n\tlayer.locked = false;\n\n\t// If layer.stretch is less than 0 (i.e reversed) inPoint and outPoint are\n\t// switched, so we need to stretch in different ways based on that.\n\tif ( layer.stretch >= 0 ) {\n\t\tlayer.outPoint = layer.containingComp.duration;\n\t} else {\n\n\t\t// If the layer is reversed and we only set the inPoint, the outPoint does\n\t\t// not stay at the same place, so we must store that point and set it after\n\t\t// we set the inpoint.\n\t\toldOutPoint = layer.outPoint;\n\t\tlayer.inPoint = layer.containingComp.duration;\n\t\tlayer.outPoint = oldOutPoint;\n\t}\n\n\t// Set the \"locked\" attribute back to what is what before we unlocked it\n\tlayer.locked = locked;\n}\n\n// The layer should only be stretched when the outpoint of the layer is after\n// or at the duration of the comp it is in.\nfunction shouldBeStretched( layer, oldDuration ) {\n\tif ( layer.stretch >= 0 ) {\n\t\treturn layer.outPoint >= oldDuration;\n\n\t// If layer.stretch is less than 0 (i.e reversed) inPoint and outPoint are\n\t// switched, so when it is revered we must check the inPoint attribute instead\n\t} else {\n\t\treturn layer.inPoint >= oldDuration;\n\t}\n}\n\nfunction maybeStretch( layer, oldDuration ) {\n\tif ( shouldBeStretched( layer, oldDuration ) ) {\n\n\t\t// The duration of the precomp should only be adjusted if it's current\n\t\t// duration is not long enough to reach the end of the comp\n\t\tif ( aeq.isComp( layer.source ) &&\n\t\t\t\tlayer.source.duration < layer.containingComp.duration - layer.inPoint ) {\n\t\t\tstretchPrecomp( layer );\n\t\t}\n\t\t// Stretch the layer to the end of the comp\n\t\tstretchLayer( layer );\n\t}\n}\n\n// Function for rounding a number up to the nearest frame. Because in AE time\n// is represented by a floting number independent of the framerate of the comp\n// we first need to convert the number in to a framenumber by dividing it with\n// the duration of each frame. Then we round that number up to the nearest whole\n// number and convert it back to the number AE use to define that frame by\n// multiplying the number with the duration of one frame.\nfunction ceilFrame( n, comp ) {\n\tvar frameDuration = comp.frameDuration;\n\treturn Math.ceil( n / frameDuration ) * frameDuration;\n}\n\n}() );\n",				"showInLauncher": false,				"showInPanel": false			},			"toolbars": {				"ToolPack": {					"index": 0				}			}		},		{			"name": "Stretch Comp",			"shortname": "SC",			"description": "Stretches Comp to fit longest layers",			"icon": "",			"cmd": {				"type": "javascript",				"cmd": "aeq.undoGroup( \"Stretch comp\", function() {\n\tvar layers = aeq.getSelectedLayers();\n\tif (layers.length === 0) {\n\t\tlayers = aeq.getLayers( aeq.getActiveComp() );\n\t}\n\tvar longest = -1;\n\taeq.forEach( layers, function( layer ) {\n\t\tlongest = Math.max( longest, layer.outPoint );\n\t} );\n\tif ( longest !== -1 ) {\n\t\tlayers[ 0 ].containingComp.duration = longest;\n\t}\n} );\n",				"showInLauncher": false,				"showInPanel": false			},			"toolbars": {				"ToolPack": {					"index": 1				}			}		},		{			"name": "Add MotionBlur",			"shortname": "Add MB",			"description": "Adds motion blur to animated layers",			"icon": "",			"cmd": {				"type": "javascript",				"cmd": "function main( comp ) {\n\taeq( \"layer:not(motionBlur)\", comp ).forEach( function( layer ) {\n\t\taeq.forEachProperty( layer, function( property ) {\n\t\t\tif ( property.isTimeVarying ) {\n\t\t\t\taddMotionBlur( layer );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} );\n\t} );\n}\n\nfunction addMotionBlur( layer ) {\n\tvar children = aeq.layer.children( layer );\n\taeq.forEach( children, addMotionBlur );\n\tif ( layer.motionBlur !== undefined && !layer.nullLayer ) {\n\t\tlayer.motionBlur = true;\n\t}\n}\n\nvar comp = aeq.getActiveComp();\nif ( comp !== null ) {\n\taeq.undoGroup( \"Add motionblur\", main, [ comp ] );\n}\n",				"showInLauncher": false,				"showInPanel": false			},			"toolbars": {				"ToolPack": {					"index": 2				}			}		},		{			"name": "tempUnParent",			"shortname": "unParent",			"description": "Detaches selected layer from children. Reattaches when button is pressed again",			"icon": "",			"cmd": {				"type": "javascript",				"cmd": "// Global to store data\ntempUnparentData = typeof tempUnparentData !== \"undefined\" ? tempUnparentData : {};\naeq.undoGroup( \"TempUnparent\", function() {\n\tvar layers = aeq.getSelectedLayers();\n\n\taeq.forEach( layers, function( layer ) {\n\t\tvar children = aeq.layer.children( layer );\n\t\tif ( children.length === 0 ) {\n\t\t\tparent( layer );\n\t\t} else {\n\t\t\tunParent( layer, children );\n\t\t}\n\t} );\n\n\tfunction unParent( layer, children ) {\n\t\ttempUnparentData[ layer.id ] = children;\n\t\taeq.forEach( children, function( child ) {\n\t\t\tchild.parent = null;\n\t\t} );\n\t}\n\n\tfunction parent( layer ) {\n\t\tvar children = tempUnparentData[ layer.id ] || [];\n\t\taeq.forEach( children, function( child ) {\n\t\t\tchild.parent = layer;\n\t\t} );\n\t}\n} );\n",				"showInLauncher": false,				"showInPanel": false			},			"toolbars": {				"ToolPack": {					"index": 3				}			}		}	],	"icons": {
	}}
